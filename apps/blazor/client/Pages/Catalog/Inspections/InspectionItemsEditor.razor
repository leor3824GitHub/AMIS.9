@using AMIS.Blazor.Infrastructure.Api
@using ClientApi = AMIS.Blazor.Infrastructure.Api
@using MudBlazor

<MudPaper Class="pa-3">
    <MudText Typo="Typo.h6">Inspection Items</MudText>

    @if (Inputs.Count == 0)
    {
        <MudText>No purchase items to inspect.</MudText>
    }
    else
    {
    <MudTable Items="Inputs" Hover="true">
            <HeaderContent>
                <MudTh>Product</MudTh>
                <MudTh class="text-end">Ordered</MudTh>
                <MudTh>Inspected</MudTh>
            </HeaderContent>
            <RowTemplate>
                <MudTd>
                    <div style="cursor:pointer" @onclick="@(() => SelectItem(context))">
                        @{
                            _productsByPurchaseItemId.TryGetValue(context.PurchaseItemId, out var product);
                        }
                        <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                            <MudText>@(product?.Name ?? "-")</MudText>
                            @if (context.AlreadyInspected)
                            {
                                <MudChip T="string" Color="Color.Secondary" Variant="Variant.Outlined">Already inspected</MudChip>
                            }
                        </MudStack>
                    </div>
                </MudTd>
                <MudTd Class="text-end">
                    <div style="cursor:pointer" @onclick="@(() => SelectItem(context))">@context.OrderedQty</div>
                </MudTd>
                <MudTd @onclick:stopPropagation="true">
                    <MudCheckBox T="bool" Value="context.IsInspected" ValueChanged="@((bool v) => OnInspectedToggle(context, v))" Disabled="@(ReadOnly || context.AlreadyInspected)" />
                </MudTd>
            </RowTemplate>
        </MudTable>

        @if (_selectedItem is not null)
        {
            <MudDivider Class="my-4" />
            <MudPaper Class="pa-3" Elevation="2">
                <MudText Typo="Typo.subtitle1">Inspection Details</MudText>
                <MudText Class="mb-2" Color="Color.Secondary">
                    @{
                        _productsByPurchaseItemId.TryGetValue(_selectedItem.PurchaseItemId, out var prod);
                    }
                    @((prod?.Name ?? "-")) � Ordered: @_selectedItem.OrderedQty
                </MudText>

                <MudForm @ref="_form">
                    <MudStack Spacing="2">
                        <MudStack Row="true" Spacing="2" AlignItems="AlignItems.Center">
                            <MudNumericField T="int" HideSpinButtons="true" Value="@_selectedItem.QtyInspected" ValueChanged="@(v => OnQtyInspectedChanged(_selectedItem, v))" Min="0" Max="@_selectedItem.OrderedQty" Immediate="true" Style="width: 120px;" Placeholder="Inspected" Label="Qty Inspected" Disabled="@(ReadOnly || _selectedItem.AlreadyInspected)" />
                            <MudNumericField T="int" HideSpinButtons="true" Value="@_selectedItem.QtyPassed" ValueChanged="@(v => OnQtyPassedChanged(_selectedItem, v))" Min="0" Max="@_selectedItem.QtyInspected" Immediate="true" Style="width: 120px;" Placeholder="Passed" Label="Qty Passed" Disabled="@(ReadOnly || _selectedItem.AlreadyInspected)" />
                            <MudNumericField T="int" HideSpinButtons="true" Value="@_selectedItem.QtyFailed" ValueChanged="@(v => OnQtyFailedChanged(_selectedItem, v))" Min="0" Max="@_selectedItem.QtyInspected" Immediate="true" Style="width: 120px;" Placeholder="Failed" Label="Qty Failed" Disabled="@(ReadOnly || _selectedItem.AlreadyInspected)" />
                            <MudSelect T="ClientApi.InspectionItemStatus" @bind-Value="_selectedItem.Status" Label="Status" Style="min-width: 200px;" Disabled="@(ReadOnly || _selectedItem.AlreadyInspected)" />
                        </MudStack>

                        <MudTextField T="string" @bind-Value="_selectedItem.Remarks" Placeholder="Remarks" Label="Remarks" />

                        <MudAlert Severity="Severity.Info" Variant="Variant.Text">
                            Single-shot is enforced: if an inspection already exists for a purchase item, you can’t add another here. Tip: Click a row to edit details.
                        </MudAlert>

                        <MudStack Row="true" Spacing="1">
                            <MudButton Variant="Variant.Outlined" Color="Color.Primary" OnClick="@(() => _selectedItem = null)">Close</MudButton>
                        </MudStack>
                    </MudStack>
                </MudForm>
            </MudPaper>
        }
    }
</MudPaper>

@code {
    [Parameter] public ICollection<PurchaseItemResponse>? PurchaseItems { get; set; }
    [Parameter] public List<ProductResponse> Products { get; set; } = new();
    [Parameter] public bool ReadOnly { get; set; } = false;
    [Inject] private IApiClient ApiClient { get; set; } = default!;

    private readonly Dictionary<Guid, ProductResponse> _productsById = new();
    private readonly Dictionary<Guid, ProductResponse> _productsByPurchaseItemId = new();

    private MudForm? _form;

    // Persistent edit map keyed by PurchaseItemId
    private readonly Dictionary<Guid, InspectionItemInput> _editMap = new();

    public class InspectionItemInput
    {
        public Guid PurchaseItemId { get; set; }
        public int OrderedQty { get; set; }
        public int QtyInspected { get; set; }
        public int QtyPassed { get; set; }
        public int QtyFailed { get; set; }
        public ClientApi.InspectionItemStatus Status { get; set; } = ClientApi.InspectionItemStatus.NotInspected;
        public string? Remarks { get; set; }
        public bool IsInspected { get; set; }
        public bool AlreadyInspected { get; set; }
    }

    public List<InspectionItemInput> Inputs { get; set; } = new();

    private InspectionItemInput? _selectedItem;

    protected override async void OnParametersSet()
    {
        if (PurchaseItems == null) return;
        
        var selectedId = _selectedItem?.PurchaseItemId;

        _productsById.Clear();
        _productsByPurchaseItemId.Clear();

        foreach (var p in Products)
        {
            if (p.Id.HasValue) _productsById[p.Id.Value] = p;
        }

        // Map purchase item id -> product for quick lookups
        foreach (var pi in PurchaseItems)
        {
            if (pi.Id.HasValue && pi.ProductId.HasValue)
            {
                if (_productsById.TryGetValue(pi.ProductId.Value, out var prod))
                {
                    _productsByPurchaseItemId[pi.Id.Value] = prod;
                }
            }
        }

        // Merge PurchaseItems into persistent edit map and rebuild Inputs view from it
        var currentIds = PurchaseItems.Where(pi => pi.Id.HasValue).Select(pi => pi.Id!.Value).ToHashSet();

        // Remove entries not present anymore
        var keysToRemove = _editMap.Keys.Where(k => !currentIds.Contains(k)).ToList();
        foreach (var key in keysToRemove)
        {
            _editMap.Remove(key);
        }

        // Add or update entries for current purchase items
        foreach (var pi in PurchaseItems)
        {
            if (!pi.Id.HasValue) continue;
            var id = pi.Id.Value;
            if (!_editMap.TryGetValue(id, out var input))
            {
                input = new InspectionItemInput
                {
                    PurchaseItemId = id,
                    OrderedQty = pi.Qty,
                    QtyInspected = 0,
                    QtyPassed = 0,
                    QtyFailed = 0,
                    Status = ClientApi.InspectionItemStatus.NotInspected,
                    Remarks = string.Empty,
                    IsInspected = false
                };
                _editMap[id] = input;
            }
            else
            {
                // keep user edits, only update the ordered qty
                input.OrderedQty = pi.Qty;
            }
        }

        // Reflect order of PurchaseItems
        Inputs = PurchaseItems
            .Where(pi => pi.Id.HasValue)
            .Select(pi => _editMap[pi.Id!.Value])
            .ToList();

        if (selectedId is Guid sid)
        {
            _selectedItem = Inputs.FirstOrDefault(i => i.PurchaseItemId == sid);
        }

        // Mark rows that already have an inspection item recorded (single-shot)
        // Access inspection items through the Inspection aggregate, not standalone search
        // For now, we'll skip this check and assume items can be inspected if not already done
        // The API will enforce single-shot constraint when creating inspection items
        foreach (var input in Inputs)
        {
            input.AlreadyInspected = false;
        }
        
        StateHasChanged();
    }

    // Row selection is handled via explicit click handlers on cells

    private void SelectItem(InspectionItemInput item)
    {
        _selectedItem = item;
        // Auto-fill on selection for fresh (not yet inspected) rows to speed up data entry
        if (!item.AlreadyInspected && !item.IsInspected && item.QtyInspected == 0 && item.QtyPassed == 0 && item.QtyFailed == 0)
        {
            item.QtyInspected = item.OrderedQty;
            item.QtyPassed = item.QtyInspected;
            item.QtyFailed = 0;
            item.Status = ClientApi.InspectionItemStatus.Passed;
            item.IsInspected = item.QtyInspected > 0;
            item.Remarks = string.IsNullOrWhiteSpace(item.Remarks) ? "Inspected" : item.Remarks;
        }
        StateHasChanged();
    }

    private void OnInspectedToggle(InspectionItemInput item, bool value)
    {
        // Update the value first
        item.IsInspected = value;
        
        // Apply side effects based on the new value
        if (item.IsInspected)
        {
            // Default to fully passed when marked inspected
            item.QtyInspected = item.OrderedQty;
            item.QtyPassed = item.QtyInspected;
            item.QtyFailed = 0;
            item.Status = ClientApi.InspectionItemStatus.Passed;
            item.Remarks = string.IsNullOrWhiteSpace(item.Remarks) ? "Inspected" : item.Remarks;
        }
        else
        {
            // Reset values when unchecking inspected
            item.QtyInspected = 0;
            item.QtyPassed = 0;
            item.QtyFailed = 0;
            item.Status = ClientApi.InspectionItemStatus.NotInspected;
            item.Remarks = string.Empty;
        }
        StateHasChanged();
    }

    private void OnQtyInspectedChanged(InspectionItemInput item, int value)
    {
        if (value < 0) value = 0;
        if (value > item.OrderedQty) value = item.OrderedQty;
        item.QtyInspected = value;
        if (item.QtyPassed > item.QtyInspected) item.QtyPassed = item.QtyInspected;
        item.QtyFailed = Math.Max(0, item.QtyInspected - item.QtyPassed);
        item.IsInspected = item.QtyInspected > 0;
        AutoSetStatus(item);
        StateHasChanged();
    }

    private void OnQtyPassedChanged(InspectionItemInput item, int value)
    {
        if (value < 0) value = 0;
        if (value > item.QtyInspected) value = item.QtyInspected;
        item.QtyPassed = value;
        item.QtyFailed = Math.Max(0, item.QtyInspected - item.QtyPassed);
        item.IsInspected = item.QtyInspected > 0;
        AutoSetStatus(item);
        StateHasChanged();
    }

    private void OnQtyFailedChanged(InspectionItemInput item, int value)
    {
        if (value < 0) value = 0;
        if (value > item.QtyInspected) value = item.QtyInspected;
        item.QtyFailed = value;
        item.QtyPassed = Math.Max(0, item.QtyInspected - item.QtyFailed);
        item.IsInspected = item.QtyInspected > 0;
        AutoSetStatus(item);
        StateHasChanged();
    }

    private static void AutoSetStatus(InspectionItemInput item)
    {
        if (item.QtyInspected == 0)
        {
            item.Status = ClientApi.InspectionItemStatus.NotInspected;
        }
        else if (item.QtyFailed == 0 && item.QtyInspected > 0)
        {
            item.Status = ClientApi.InspectionItemStatus.Passed;
        }
        else if (item.QtyFailed > 0 && item.QtyPassed > 0)
        {
            item.Status = ClientApi.InspectionItemStatus.Partial;
        }
        else if (item.QtyFailed > 0 && item.QtyPassed == 0)
        {
            item.Status = ClientApi.InspectionItemStatus.Rejected;
        }
    }

    public bool Validate()
    {
        foreach (var i in Inputs)
        {
            if (i.QtyInspected > i.OrderedQty) return false;
            if (i.QtyPassed + i.QtyFailed != i.QtyInspected) return false;
        }
        return true;
    }
}
